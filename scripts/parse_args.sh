#!/bin/bash
# Define options and positional arguments
#ARG_POSITIONAL_SINGLE([suite],[Benchmark suite (e.g. gapbs)])
#ARG_POSITIONAL_SINGLE([workload],[Name of the workload to run (e.g. pr)])
#ARG_OPTIONAL_SINGLE([config_file],[f],[YAML configuration file for workload parameters],[""])
#ARG_OPTIONAL_SINGLE([output_dir],[o],[Output directory],[""])
#ARG_OPTIONAL_SINGLE([instrument],[i],[Instrumentation tool: 'pebs', 'damon' (default: none)],["none"])
#ARG_OPTIONAL_SINGLE([sampling_rate],[s],[Damon Sampling Rate (microseconds), default: 5000],[5000])
#ARG_OPTIONAL_SINGLE([aggregate_rate],[a],[Damon Aggregate Rate (milliseconds), default: 100],[100])
#ARG_OPTIONAL_SINGLE([min_damon],[n],[Min # of Damon regions],[""])
#ARG_OPTIONAL_SINGLE([max_damon],[m],[Max # of Damon regions],[""])
#ARG_OPTIONAL_SINGLE([auto_access_bp],[x],[Damon auto access_bp flag],[""])
#ARG_OPTIONAL_SINGLE([auto_aggrs],[y],[Damon auto aggregation flag],[""])
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='hvfoisanmxy'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_config_file=""
_arg_output_dir=""
_arg_instrument="none"
_arg_sampling_rate="5000"
_arg_aggregate_rate="100"
_arg_min_damon=""
_arg_max_damon=""
_arg_auto_access_bp=""
_arg_auto_aggrs=""


print_help()
{
	printf '%s\n' "Script to run workloads with various options"
	printf 'Usage: %s [-h|--help] [-v|--version] [-f|--config_file <arg>] [-o|--output_dir <arg>] [-i|--instrument <arg>] [-s|--sampling_rate <arg>] [-a|--aggregate_rate <arg>] [-n|--min_damon <arg>] [-m|--max_damon <arg>] [-x|--auto_access_bp <arg>] [-y|--auto_aggrs <arg>] <suite> <workload>\n' "$0"
	printf '\t%s\n' "<suite>: Benchmark suite (e.g. gapbs)"
	printf '\t%s\n' "<workload>: Name of the workload to run (e.g. pr)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
	printf '\t%s\n' "-f, --config_file: YAML configuration file for workload parameters (default: '""')"
	printf '\t%s\n' "-o, --output_dir: Output directory (default: '""')"
	printf '\t%s\n' "-i, --instrument: Instrumentation tool: 'pebs', 'damon' (default: '"none"')"
	printf '\t%s\n' "-s, --sampling_rate: Damon Sampling Rate (microseconds) (default: '5ms')"
	printf '\t%s\n' "-a, --aggregate_rate: Damon Aggregate Rate (microseconds) (default: '100ms')"
	printf '\t%s\n' "-n, --min_damon: Min # of Damon regions (default: '""')"
	printf '\t%s\n' "-m, --max_damon: Max # of Damon regions (default: '""')"
	printf '\t%s\n' "-x, --auto_access_bp: Damon auto access_bp flag (default: '""')"
	printf '\t%s\n' "-y, --auto_aggrs: Damon auto aggregation flag (default: '""')"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				v1.0.0
				exit 0
				;;
			-v*)
				v1.0.0
				exit 0
				;;
			-f|--config_file)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_config_file="$2"
				shift
				;;
			--config_file=*)
				_arg_config_file="${_key##--config_file=}"
				;;
			-f*)
				_arg_config_file="${_key##-f}"
				;;
			-o|--output_dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output_dir="$2"
				shift
				;;
			--output_dir=*)
				_arg_output_dir="${_key##--output_dir=}"
				;;
			-o*)
				_arg_output_dir="${_key##-o}"
				;;
			-i|--instrument)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_instrument="$2"
				shift
				;;
			--instrument=*)
				_arg_instrument="${_key##--instrument=}"
				;;
			-i*)
				_arg_instrument="${_key##-i}"
				;;
			-s|--sampling_rate)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_sampling_rate="$2"
				shift
				;;
			--sampling_rate=*)
				_arg_sampling_rate="${_key##--sampling_rate=}"
				;;
			-s*)
				_arg_sampling_rate="${_key##-s}"
				;;
			-a|--aggregate_rate)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_aggregate_rate="$2"
				shift
				;;
			--aggregate_rate=*)
				_arg_aggregate_rate="${_key##--aggregate_rate=}"
				;;
			-a*)
				_arg_aggregate_rate="${_key##-a}"
				;;
			-n|--min_damon)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_min_damon="$2"
				shift
				;;
			--min_damon=*)
				_arg_min_damon="${_key##--min_damon=}"
				;;
			-n*)
				_arg_min_damon="${_key##-n}"
				;;
			-m|--max_damon)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_max_damon="$2"
				shift
				;;
			--max_damon=*)
				_arg_max_damon="${_key##--max_damon=}"
				;;
			-m*)
				_arg_max_damon="${_key##-m}"
				;;
			-x|--auto_access_bp)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_auto_access_bp="$2"
				shift
				;;
			--auto_access_bp=*)
				_arg_auto_access_bp="${_key##--auto_access_bp=}"
				;;
			-x*)
				_arg_auto_access_bp="${_key##-x}"
				;;
			-y|--auto_aggrs)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_auto_aggrs="$2"
				shift
				;;
			--auto_aggrs=*)
				_arg_auto_aggrs="${_key##--auto_aggrs=}"
				;;
			-y*)
				_arg_auto_aggrs="${_key##-y}"
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'suite' and 'workload'"
	test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_suite _arg_workload "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

print_cmd_args()
{
    echo "Suite: $_arg_suite"
    echo "Workload: $_arg_workload"
    echo "Output directory: $_arg_output_dir"
    echo "Config file: $_arg_config_file"
    echo "Instrumentation: $_arg_instrument"
    echo "Sampling rate: $_arg_sampling_rate us"
    echo "Aggregate rate: $_arg_aggregate_rate ms"
    echo "Min Damon regions: $_arg_min_damon"
    echo "Max Damon regions: $_arg_max_damon"
    echo "Auto access_bp: $_arg_auto_access_bp"
    echo "Auto aggrs: $_arg_auto_aggrs"
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"
